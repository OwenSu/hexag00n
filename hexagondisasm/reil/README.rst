***************
REIL Translator
***************

Hexagon to REIL translator, intended primarily to be used with `BARF`_, which implements a modified version of the original `REIL specification`_. 

.. _REIL specification: https://www.zynamics.com/binnavi/manual/html/reil_language.htm

.. _BARF: https://github.com/programa-stic/barf-project

The Hexagon instructions are defined in the Reference Manual through another set of more simple instructions, the instruction's **behavior**. This behavior is actually a pseudo-code that implements Hexagon instructions with simpler (low level), atomic instructions, that are closer to the REIL language. This pseudo-code is not formally defined (AFAIK), there is no specification for it in the Reference Manual, but it is very regular, so an unofficial specification can be derived from it. This will be done as the behavior instructions are being included to the translator.

The translation is perform on the behavior pseudo-code instructions themselves, so the translator relies on the correct definition of the Hexagon instructions behavior. The behavior code is parsed using `PLY`_, the translation is performed during the same parsing process (as opposed to constructing an AST and processing it later).

As it is done in BARF, there is an ``HexagonTranslator`` class that exposes a ``translate`` function to perform the translation of ``HexagonInstruction`` objects (that represent actual instructions).

As opposed to BARF, this parser (``HexagonBehaviorParser``) is used for the translation process (parses the instructions behavior pseudo-code) while in BARF the parsers are used in the disassembly process (they parse Capstone's output to construct the disassembled instructions).

::

    BARF
    ----

        Binary -> ArchDisassembler (Capstone) -> ArchParser -> ArchInstruction

        ArchInstruction -> ArchTranslator -> REIL


    Hexag00n
    --------

        Binary -> HexagonDisassembler -> HexagonInstruction

        HexagonInstruction -> HexagonTranslator -> HexagonBehaviorParser (PLY) -> REIL


.. _PLY: https://github.com/dabeaz/ply


Parser
======

This section explains the inner workings of the parser generated by PLY, citing the `PLY documentation`_ as a guide.

The parser class ``HexagonBehaviorParser`` is derived from base class (``Parser``, taken from PLY examples) whose sole purpose is to encapsulate the parsing definitions inside a class, instead of having them exposed in the parser module (``hexagonparser.py``).


	The semantic behavior of a language is often specified using a technique known as syntax directed translation. In syntax directed translation, attributes are attached to each symbol in a given grammar rule along with an action. Whenever a particular grammar rule is recognized, the action describes what to do.

The *action* the parser takes every time a rule is recognized is the generation of the equivalent REIL code, the parser functions are "overloaded" so it does most of the translation process.

	A good way to think about syntax directed translation is to view each symbol in the grammar as a kind of object. Associated with each symbol is a value representing its "state" (for example, the val attribute above). Semantic actions are then expressed as a collection of functions or methods that operate on the symbols and associated values.

Each expression recognized by the parser generates an object whose "state" is the name of the register that contains its value. This register can either be an Hexagon register or a REIL temporal register created for this purpose.

	The output of yacc.py is often an Abstract Syntax Tree (AST). However, this is entirely up to the user. If desired, yacc.py can also be used to implement simple one-pass compilers.

The parser generated by Yacc in this translator is a **one pass compiler**, no AST is used, each time a grammar rule is recognized its corresponding action generates the equivalent REIL code. This method works good enough for most cases, except for more elaborated logic like IF conditionals, where the parser would first generate the REIL code of the statements inside the IF block before generating the REIL branch of the IF that controls its execution (because the parser recognizes the inner grammar rules inside the IF block before noticing that it belongs to an IF clause). The same happens for IF/ELSE conditionals, or FOR loops.

To accommodate those other cases, instruction containers are used, to represent a list of sequential instructions (similar to basic blocks), encapsulated in ``HexagonTranslationBuilder`` objects, that allows to combine them in the right order (e.g., putting the IF branch before the statements inside the IF block). This class inherits from BARF's ``TranslationBuilder`` which contains the list of generated REIL instructions (``self._instructions``), and in its derived class the ``self._value`` attribute is added to represent the state of the REIL instructions: if the list of REIL instructions represent an expression it will have the name of the register containing its value; if the instructions represent a statement ``self._value`` will be ``None`` (as a statement already resolved its value, e.g., performing an assignment).


.. _PLY documentation: http://www.dabeaz.com/ply/ply.html#ply_nn22


Contexts of use
===============

The translator (and the parser) will be used in two clearly different contexts:

* *Production* (normal) use, similar to BARF, where a binary is disassembled and later translated into its REIL equivalent.
* *Development* (and testing) use, where a template behavior (not belonging to a particular binary or disassembled instruction) is translated in isolation to REIL.

It's worth differentiating between the two of them because separate process chains are being used and some considerations have to be noted that will have an impact on the resulting code.

The **development context** permits to test any Hexagon instruction behavior (extracted from the Reference Manual and stored in the Hexag00n instruction definitions database, ``instruction_definitions.pkl``) in isolation, without the need of a binary that contains such instruction, leaving aside the disassembly process. There is no ``HexagonInstruction`` object (created by the ``HexagonDisassembler``) available, the behavior pseudo-code instructions (text strings) are all that are needed.

The behaviors parsed in those contexts are also different (and the parser should support both). The operands (registers and immediates) in the production context are actual operands, e.g., ``R7`` or ``#0x1008``, whereas in the development context, the operands of the behavior instructions are template operands (like the operands in the Hexagon instructions themselves) with names that link them to the instruction encoding field names, e.g., ``Rd`` or ``#s16``. The REIL is targeted to actual operands, but the template ones are also of interest (supported by the parser with additional lexing and parsing rules). This means being able to create REIL registers with template names (which is not a problem since register names are just strings) and also to convert template immediates to integers with dummy values (because REIL immediates need an integer and won't accept a string like ``#s16``).

::

    Development context
    -------------------

        Hexagon instruction behavior -> HexagonBehaviorParser -> REIL (template operands)

    Normal (BARF-like) context
    --------------------------

        Binary -> HexagonDisassembler -> HexagonInstruction

        HexagonInstruction -> Replace template operands with actual ones ->

            -> HexagonTranslator (translate() API) -> HexagonBehaviorParser -> REIL


BARF integration
================

From the example in ``translate-reil-generic.py`` and the BARF core in ``barf.py``, the BARF translation API could be described as:

::

    barf.translate() ->  barf.disassemble() -> barf.disassembler.disassemble()

where ``barf.disassembler`` has been set to be ``HexagonDisassembler`` (in the ``load_architecture`` call). So a ``disassembler`` method is added to ``HexagonDisassembler``, which will function just as a wrapper to the method where the actual disassembly takes place: ``disasm_one_inst``.


that won't be addressed now, is that ``barf.disassemble()`` loads 16 bytes from the binary to disassemble in one instruction, that is enough to disassemble one Hexagon instruction (which are all 4 long).

The same restriction as in the IDA applies, the disassembler has to be used in sequential order (which is the case of BARF) for the packet to be decoded correctly. Some of the IDA functionality (like the use of a ``disasm_cache`` to disassemble an entire packet at a time) could be moved to the disassembler, to be used also with BARF and any other project that would make use of it.


TODOs
=====

* Define a small subset of Hexagon instructions to translate for the initial version of the translator (whose objective is not the translation itself but to define the underlying mechanism of the translation process). These subset should be the easiest of the most used instructions (as observed in the binary examples like ``factorial.elf``).

* Define a basic API to use the translator. This API should be as close as BARF's as possible (even though their underlying mechanisms of translation differ), to facilitate its future integration.

* Explain difference between BARF translation and this one.

* Define an informal specification for the behavior pseudo-code instructions (maybe a summary, compilation, or classification are more adequate terms). At the very least, every pseudo-code instruction added to the translator should be included in a list.

* Add an example in this documentation of a simple translation of an Hexagon instruction with 3 or 4 behavior pseudo-code instructions.

* Define vocabulary. There is an Hexagon instruction (e.g., ``Rd = add(Rs, #s16)``) and its corresponding behavior pseudo-code instructions that represent it (e.g., ``Rd = Rs + #s``). Only when the context is clear enough the simple "instruction" term (without additional qualifications) should be used.

* Introduce PLY translation source code progressively, clearly documenting and explaining what it does, do not add it all at once.

* Review PLY documentation, the current implementation of the translator generates the REIL code in a single pass (during the parsing process), review the name of that parsing mode. Is this mode enough to cover all of the logic of the behavior pseudo-code like ``if/else`` branches and loops?

* Add unit testing (similar to BARF).

* Currently this translator is a sub-package (``reil``) of the disassembler python package (``hexagondisasm``). Should this be in a separate package?

* Review the behavior instructions of the repository database (``hexagondisasm/data/instruction_definitions.pkl``) to check how many Hexagon behaviors have been correctly parsed from the Manual, and if that's enough for the first version of the translator.

* Add PLY to the dependencies in ``setup.py``.

* Teminology: *actual* vs *template* objects, avoid using the term *generic* instead of *template*, to follow the terminology used in the disassembler (``InstructionTemplate`` vs ``HexagonInstruction``, the actual instruction).
